# 2.1-1

[*31*, _41_, 59, 26, 41, 58]

[31, *41*, _26_, 59, 41, 58]

[*31*, 41, _26_, 59, 41, 58]

[26, 31, *41*, _59_, 41, 58]

[26, 31, 41, *59*, _41_, 58]

[26, 31, 41, 41, *59*, _58_]

[26, 31, 41, 41, _58_, *59*]

# 2.1-2

Loop invariant: At the start of each loop index i, the total sum consists of the sum of the elements for A[1:i-1].

- Initialization: The sum starts at 0, representing the sum of zero elements.
- Maintenance: Each increment of `i` preserves the sum of the previous subarray.
- Termination: The loop terminates after adding the last element to the sum.

# 2.1-4

Pseudocode:

```
Linear-Search(A, n, v)
value_index = NIL
for i = 1 to n
  if A[i] == v
    value_index = i
    return value_index
return value_index

```

Loop invariant: At the start of each loop, the value has not been found yet.

- Initialization: The value has not been found, since no values have been searched.
- Maintenance: Each increment of `i` guarantees that the value has not been found, as the algorithm halts when the value has been found.
- Termination: The loop terminates when all values has been visited. If the search value has not been found, the algorithm always returns a NIL value.

# 2.1-5

Pseudocode:

```
ADD-BINARY-INTEGERS(A, B, C, n)
carry = 0
for i = 0 to n
  C[i] = carry
  if A[i] == 1 and B[i] == 1
    carry = 1
  else if A[i] == 1 or B[i] == 1
    C[i] = 1
    carry = 0
  else {
    carry = 0
  }
  C[n] = carry

return C
```

# 2.2-1

$O(n^3)$

# 2.2-2

- Loop invartiant: Same as insertion sort, left subarray is sorted throughout all iterations.
- It only needs to compare the second to last element, as the last element is guaranteed to be in sorted order.
- Approximately $n^2 + a*n + b$ instructions, therefore $O(n^2)$.
- Worst case is not better, this algorithm does not change depending on the input.

# 2.2-3

- Average runtime: Half of input
- Worst: Entire input
- Average and worst: $O(n)$

# 2.2-4

Linear search through the array once to check if it is sorted, if not sort it afterwards.

# 2.3-1

1. 3 41 52 26 38 57 9 49
2. 3 41 52 26 | 38 57 9 49
3. 3 41 | 52 26 | 38 57 | 9 49
4. 3 41 | 26 52 | 38 57 | 9 49
5. 3 26 41 52 | 9 38 49 57
6. 3 9 26 38 41 49 52 57

# 2.3-2

Since `q` is calculated by $q = floor((q + r) / 2)$, both sides of the recursion calls will converge to each respective bound. For the "right" recursive call, it is bounded by r since floor$(q+r)/2 \le r$ for $q \in [p, r - 2]$ and floor$(q + r) / 2 = r$ for $q \in [r - 1, r]$. This means that the algorithm will stop when q has reached r. Similarly for the "left" recursion call, floor$((p, q) / 2) \ge p $ for $q \in [p + 2, r]$. and floor$((p, q) / 2) = p $ for $q \in [p, p + 1]$.

# 2.3.3

Loop invariant for 12:18
At the start of each iteration `i`, the indices A[p:i] are sorted.

- Initialization: The array A[p:k] has length zero, and is therefore sorted. The arrays `L` and `R` are each sorted subarrays of A[p:r].
- Maintenance: For each iteration `i`, the lowest value of the next unused values of `L` and `R` is added to `A`. Since both `L` and `R` are sorted, this guarantees that this is the next smallest possible value to be added. The first while loop terminates when one of the arrays `L` or `R` are empty. When this happens, the only values left to be added are already in sorted order. Depending on if `L` or `R` is empty, the corresponding while loop is used to add the rest of the values.
- Termination: Since length(L) + length(R) = Length(A[p:r]), and the three while loops runs until `L` and `R` are empty, we guarantee that all values are added in sorted order to A.

# 2.3-4

$k \in \{2,3,.. : k>1\}$

$T(2^k) = 2 * T(2^{k-1}) + 2^k$

$T(2^k) = 2 * 2 * T(2^{k-2}) + 2^k + 2 * 2^{k - 1}$

$T(2^k) = 2 * 2 * 2 * T(2^{k-3}) + 2^k + 2 * 2^{k - 1} + 2 * 2 * 2^{k - 2}$

$T(2^k) = 2^{k - 1} * T(2) + \sum^K 2^k$

$T(2^k) = 2^{k - 1} * T(2) + k * 2^k$

$T(2^k) = 2^{k - 1} * T(2) + log_2(2^k) * 2^k$

$\Theta(T(2^k)) = \Theta(log_2(2^k) * 2^k)$

$\Theta(T(n)) = \Theta(log_2(n) * n)$

# 2.3-5

```
Init: q = n
A(n, q)
  if q == 0 {
    return;
  }

  A(n, q - 1)

  key = A[q]
  j = q - 1
  while (j > 0 AND A[j] > key)
    A[j + 1] = A[j]
    j = j - 1

  A[j + 1] = key
```

- Best recurrences: n
- Worst recurrences: n
- Best insertions: 1
- Worst insertions: n

Worst case $\Theta(n^2)$

# 2.3-6
```
BinarySearch(A, n, s)
i = 0
j = n / 2
k = n

while (j != i OR j != k)
  if A[j] > s
    k = j
    j = (k - i) / 2
  else if A[j] < s
    i = j
    j = i + (k - i) / 2
  
  
  if A[j] == s
    return j
  
return nil
```