Upcasting: This is one of the most common situations where the static and dynamic types differ. When a pointer or reference of a base class points or refers to an object of a derived class, the static type is the base class but the dynamic type is the derived class. The compiler only knows the type of the pointer or reference (base class), but at runtime, the actual object the pointer or reference points to could be of the derived class.

Polymorphism: When virtual functions are used, the static and dynamic types of an expression can differ. The static type of the pointer or reference is the base class, and the dynamic type could be any class derived from the base class. When a virtual function is called through the pointer or reference, the version of the function that matches the dynamic type is invoked, a mechanism known as dynamic binding.

Abstract Base Classes and Interfaces: Abstract base classes (also called interfaces in some contexts) only define function signatures without implementing them. An abstract base class cannot be instantiated. However, a pointer or reference to an abstract base class can point or refer to objects of any class that inherits from the abstract base class and implements its pure virtual functions. In this case, the static type would be the abstract base class, and the dynamic type would be the derived class that implements the abstract base class. This is commonly used in designs that involve the strategy pattern, factory pattern, or any situation where the actual behavior needs to be decided at runtime.